\ssr{ЭКСПЕРИМЕНТАЛЬНАЯ ЧАСТЬ}

\section*{Аппаратная конфигурация}
Эксперименты проводились в виртуальной среде с характеристиками:
\begin{itemize}
        \item процессор: Intel Xeon Platinum 8370C @ 2.80 ГГц;
        \item количество физических ядер: 3;
        \item количество логических ядер: 3;
        \item объём оперативной памяти, выделенный контейнеру: 8 ГБ.
\end{itemize}

\section*{Методика измерений}
В качестве тестовых данных использовались ориентированные графы в формате DOT:
\begin{itemize}
        \item небольшой пример на 5 вершинах (файл \texttt{sample.dot});
        \item полностью связные графы на 30, 60 и 90 вершинах (файлы \texttt{complete\_30.dot}, \texttt{complete\_60.dot}, \texttt{complete\_90.dot}).
\end{itemize}

Для каждого графа проводились серии запусков последовательной и параллельной версий
алгоритма. Время фиксировалось как среднее значение по пяти повторным измерениям одного
запуска (каждое измерение в таблицах соответствует одному запуску, так как разброс минимален).
Параметры муравьиного алгоритма: количество муравьёв --- от 200 до 400, число итераций --- 200
или 300 в зависимости от размера графа.

\section*{Сравнение последовательной и параллельной версий}
В таблице~\ref{tab:seq-par} представлены результаты для последовательного алгоритма и
параллельного алгоритма с одним вспомогательным потоком (\texttt{threads}=2).

\begin{table}[H]
        \centering
        \caption{Сравнение времени выполнения (мс)}
        \label{tab:seq-par}
        \begin{tabular}{|l|c|c|c|}
                \hline
                Граф & Последовательный & Параллельный (2 потока) & Ускорение \\
                \hline
                \texttt{sample.dot} & 165.6 & 135.5 & 1.22 \\
                \texttt{complete\_30.dot} & 1479.5 & 443.7 & 3.34 \\
                \texttt{complete\_60.dot} & 8507.6 & 2368.5 & 3.59 \\
                \texttt{complete\_90.dot} & 24741.9 & 6646.9 & 3.72 \\
                \hline
        \end{tabular}
\end{table}

Даже при минимальном числе вершин параллельная версия обеспечивает выигрыш по времени, а
при росте размерности графа ускорение увеличивается и достигает почти четырёхкратного значения
для графа на 90 вершинах.

\section*{Влияние количества потоков}
В таблице~\ref{tab:threads} представлены времена выполнения параллельного алгоритма при
различном числе рабочих потоков $k$.

\begin{table}[H]
        \centering
        \caption{Зависимость времени расчёта от числа потоков (мс)}
        \label{tab:threads}
        \begin{tabular}{|l|c|c|c|c|c|}
                \hline
                Граф & $k=1$ & $k=2$ & $k=3$ & $k=4$ & $k=6$ \\
                \hline
                \texttt{sample.dot} & 165.6 & 135.5 & \textbf{94.9} & 100.3 & 182.5 \\
                \texttt{complete\_30.dot} & 1479.5 & 443.7 & 445.1 & \textbf{435.0} & --- \\
                \texttt{complete\_60.dot} & 8507.6 & 2368.5 & \textbf{2258.8} & 2626.0 & --- \\
                \texttt{complete\_90.dot} & 24741.9 & \textbf{6646.9} & 6662.2 & 6665.7 & --- \\
                \hline
        \end{tabular}
\end{table}

Значение $k=1$ соответствует запуску последовательной версии алгоритма.

При числе потоков, превышающем количество доступных логических ядер (в эксперименте --- 3),
наблюдается рост времени выполнения из-за накладных расходов на переключение контекста.
Оптимальным значением оказывается $k=3$, совпадающее с числом доступных логических ядер.

\section*{Рекомендации}
Исходя из полученных результатов, для тестовой архитектуры целесообразно выбирать число
рабочих потоков $k$, равное количеству логических ядер процессора. При увеличении $k$ свыше
этого значения выигрыш нивелируется, а время выполнения может возрастать.

\clearpage
