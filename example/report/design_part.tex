\chapter{Конструкторская часть}

\section{Схемы алгоритмов умножения матриц}

На рисунках~\ref{scheme:standart} —~\ref{scheme:optCountMulV} приведены схемы алгоритмов умножения матриц.

\scheme{standart}{Схема стандартного алгоритма умножения матриц}{standart}

\scheme{winograd}{Схема алгоритма Винограда умножения матриц}{Winograd}

\scheme{MulH}{Схема алгоритма вычисления сумм произведений пар соседних элементов строк матрицы}{countMulH}

\scheme{MulV}{Схема алгоритма вычисления сумм произведений пар соседних элементов столбцов матрицы}{countMulV}

\scheme{winograd_opt}{Схема оптимизированного алгоритма Винограда умножения матриц}{optWinograd}

\scheme{MulH_opt}{Схема оптимизированного алгоритма вычисления сумм произведений пар соседних элементов строк матрицы}{optCountMulH}

\scheme{MulV_opt}{Схема оптимизированного алгоритма вычисления сумм произведений пар соседних элементов столбцов матрицы}{optCountMulV}

\section{Модель вычислений}

Модель вычислений для оценки трудоёмкости алгоритмов:
\begin{itemize}[left=\parindent]
	\item операции с трудоёмкостью 1: =,~+,~-,~+=,~-=,~<,~>,~==,~!=,~>=,~<=,~[],~<<,~>>,~++,~--;
	\item операции с трудоёмкостью 2: *,~/,~//,~\%,~*=,~/=,~//=;
	\item трудоёмкость оператора выбора \texttt{if} рассчитывается по формуле\eqref{eq:ifeq};
	\begin{equation} \label{eq:ifeq}
		f_{if} = f_{\text{условия}} +
		\begin{cases}
			f_A, & \text{если условие выполняется;}\\
			f_B, & \text{иначе}
		\end{cases}
	\end{equation}
	\item трудоёмкость цикла \texttt{for} рассчитывается по формуле\eqref{eq:foreq};
	\begin{equation}\label{eq:foreq}
		f_{\text{for}} = f_{\text{инициализации}} + f_{\text{сравнения}} +
		N(f_{\text{тела}} + f_{\text{инкремента}} + f_{\text{сравнения}})
	\end{equation}
	\item трудоёмкость вызова функции принимается равной 0.
\end{itemize}

Принятая модель отражает реальное распределение затрат по операциям и позволяет более точно сравнивать трудоёмкость различных алгоритмов.

\section{Трудоёмкость стандартного алгоритма}
Трудоёмкость вложенных циклов:  
внутреннего цикла по $k$, среднего цикла по $j$, 
и внешнего цикла по $i$. Итогом будет полная трудоёмкость алгоритма.

\begin{equation}
	f_C = 2 + 11P
\end{equation}

\begin{equation}
	f_B = 2 + M(2 + f_C) = 11MP + 4M + 2
\end{equation}

\begin{equation}
	f_A = 2 + N(2 + f_B) = 11NMP + 4NM + 4N + 2
\end{equation}

\begin{equation}
	f_{\text{standart}} = f_A
\end{equation}

Полная трудоёмкость стандартного алгоритма имеет вид:
\begin{equation}
	f_{\text{standart}} = 11NMP + 4NM + 4N + 2,
\end{equation}
где главный член $11NMP$ определяет асимптотическую сложность $O(NMP)$.

Принятая модель отражает реальное распределение затрат по операциям и позволяет более точно сравнивать трудоёмкость различных алгоритмов.

\section{Алгоритм Винограда}

Алгоритм Винограда предусматривает выполнение дополнительного подготовительного этапа, на котором для каждой строки первой матрицы и каждого столбца второй матрицы заранее вычисляются вспомогательные значения. Эти данные используются при последующем перемножении, что позволяет сократить количество умножений в основном цикле. После этапа предварительных вычислений выполняется основной цикл, формирующий элементы результирующей матрицы на основе уже готовых промежуточных сумм.
Такой подход распределяет вычислительную нагрузку между фазами алгоритма и обеспечивает частичное снижение трудоёмкости операции умножения. В рамках модели вычислений трудоёмкость каждого из этапов — инициализации, подготовки строк и столбцов, а также основного цикла — может быть представлена следующими выражениями:

\begin{equation}
	f_{init} = N + M,
\end{equation}

\begin{equation}
	f_{mulH} = 9.5PN + 6N + 2,
\end{equation}

\begin{equation}
	f_{mulV} = 9.5MP + 6M + 2,
\end{equation}

\begin{equation}
	f_{main}^{\wedge} = 16NMP + 16NM + 4N + 2,
\end{equation}

\begin{equation}
	f_{main}^{\vee} = 16NMP + 30NM + 4N + 2.
\end{equation}

Полная трудоёмкость алгоритма Винограда для двух случаев вычислений имеет вид:

\begin{equation}
	f_{Winograd}^{\wedge} = 16NMP + 16NM + 9.5MP + 9.5PN + 11N + 7M + 6,
\end{equation}

\begin{equation}
	f_{Winograd}^{\vee} = 16NMP + 30NM + 9.5MP + 9.5PN + 11N + 7M + 6,
\end{equation}

где главный член $16NMP$ определяет асимптотическую сложность $O(NMP)$.

Несмотря на усложнение структуры программы, уменьшение числа умножений компенсирует рост количества сложений и обращений к памяти.

\section{Оптимизированный алгоритм Винограда}

Оптимизированная версия алгоритма Винограда реализует предварительные вычисления с применением буферизации, что позволяет эффективно хранить и повторно использовать промежуточные результаты. Благодаря этому снижается количество выполняемых операций и уменьшается число обращений к памяти в основных циклах.
Такое улучшение направлено на сокращение вычислительных затрат и повышение общей производительности метода. В соответствии с принятой моделью вычислений, трудоёмкость отдельных компонентов алгоритма — этапа инициализации, расчёта вспомогательных сумм и основного цикла умножения — выражается следующими зависимостями:

\begin{equation}
	f_{init} = N + M,
\end{equation}

\begin{equation}
	f_{optMulH} = 6PN + 5N + 2,
\end{equation}

\begin{equation}
	f_{optMulV} = 6MP + 5M + 2,
\end{equation}

\begin{equation}
	f_{optMain}^{\wedge} = 10NMP + 14NM + 4N + 2,
\end{equation}

\begin{equation}
	f_{optMain}^{\vee} = 10NMP + 25NM + 4N + 2.
\end{equation}

Полная трудоёмкость оптимизированного алгоритма Винограда имеет вид:

\begin{equation}
	f_{optWinograd}^{\wedge} = 10NMP + 14NM + 6MP + 6PN + 10N + 6M + 6,
\end{equation}

\begin{equation}
	f_{optWinograd}^{\vee} = 10NMP + 25NM + 6MP + 6PN + 10N + 6M + 6,
\end{equation}

где главный член $10NMP$ определяет асимптотическую сложность $O(NMP)$.

Снижение трудоёмкости достигается за счёт перераспределения вычислений и повторного использования ранее рассчитанных выражений.

\section*{Вывод}

Разработаны схемы стандартного алгоритма умножения матриц, алгоритма Винограда и его оптимизированного варианта с буферизацией. Для каждого алгоритма введена модель вычислений и проведена оценка трудоёмкости.

Анализ показал, что все три алгоритма имеют асимптотическую сложность $O(NMP)$, но отличаются константными множителями. 
Стандартный алгоритм обладает наибольшей трудоёмкостью, 
алгоритм Винограда уменьшает количество операций за счёт предварительных вычислений, оптимизированный алгоритм Винограда с буферизацией дополнительно снижает трудоёмкость за счёт повторного использования ранее вычисленных значений.

\clearpage
